#Analysis 1 - Top 25% of coefficient of variation Small SOM

Purpose:

In this analysis I am checking to see if using the top 25% of genes based on co-efficient of variation using SOM clustering. This time I am going to do smaller SOMs only nine.


Required Libraries
```{r}
library(ggplot2)
library(reshape2)
library(kohonen)
```

Cluster visualization functions 

```{r}
#ClusterVis
clusterVis <- function(clustNum){
  
  sub_cluster <- subset(plot.data, som$unit.classif==clustNum)
  sub_data <- sub_cluster[,c(1:11)] # just the sample types
  m.data <- melt(sub_data) 
  p <- ggplot(m.data, aes(x=variable, y=value))
  p + geom_point(alpha=0.5,position="jitter", size=1) + 
    geom_boxplot(alpha=0.75, outlier.size=0) + 
    theme_bw() + 
    theme(text = element_text(size=30),
          axis.text.x = element_text(angle=90, 
                                     vjust=1)) +
    xlab("Library") +
    ylab("Scaled Gene Expression")
}
```

###clusterVis_line

Need to remove unused x-axis values. 

```{r, eval=FALSE}
clusterVis_line <- function(clustNum) {
  sub_cluster <- subset(plot.data, som$unit.classif==clustNum)
  sub_data <- sub_cluster[,c(1:11)] # just the sample types
  m.data <- melt(sub_data)
  m.data$region <- ifelse(grepl("SAM", m.data$variable, ignore.case = T), "SAM", 
                          ifelse(grepl("leaf", m.data$variable, ignore.case = T), "leaf", "other"))
  head(m.data)
  m.data <- within(m.data, lineGroup <- paste(gene,sep='.'))
  ggplot(m.data, aes(variable, value, group = lineGroup)) + 
    geom_line(alpha = .1) + 
    geom_point(alpha = .0) +
    theme_bw() +
    facet_grid(.~region) +
    theme(axis.text.x = element_text(size=20, 
                                angle=90, 
                                vjust=1))
  }

```


##clusterVis_region 

not finished. 
```{r}
clusterVis_region <- function(clustNum){
  sub_cluster <- subset(plot.data, som$unit.classif==1)
  sub_data <- sub_cluster[,c(1:11)] # just the sample types
  m.data <- melt(sub_data)
  m.data$region <- ifelse(grepl("SAM", m.data$variable, ignore.case = T), "SAM", 
                          ifelse(grepl("leaf", m.data$variable, ignore.case = T), "leaf", "other"))

  m.data$stage <- ifelse(grepl("a1", m.data$variable, ignore.case = T), "1", 
                          ifelse(grepl("b2", m.data$variable, ignore.case = T), "2", 
                            ifelse(grepl("c3", m.data$variable, ignore.case = T), "3", 
                                ifelse(grepl("d4", m.data$variable, ignore.case = T), "4",
                                  ifelse(grepl("e5", m.data$variable, ignore.case = T), "5", "other")
                                  )
                                )
                             )
                          )
  
  head(m.data)       
  p <- ggplot(m.data, aes(y=value, x=variable, fill = stage))
  p + geom_point(alpha=0.5,position="jitter", size=1) + 
    geom_boxplot(alpha=0.70, outlier.size=0) +
    scale_colour_manual(values = c("darkorchid1", "coral")) +
    theme(legend.text = element_text(
      size = 30, 
      face = "bold"), 
      text = element_text(size=40)) + 
    theme_bw() + 
    theme(text = element_text(size=30)) +
    facet_grid(.~region) 
}
```

##genesInCluster()

```{r}
#Prereq annotation files for function

annotation1<- read.delim("../data/ITAG2.3_all_Arabidopsis_ITAG_annotations.tsv", header=FALSE)  #Changed to the SGN human readable annotation
colnames(annotation1) <- c("ITAG", "SGN_annotation")
annotation2<- read.delim ("../data/ITAG2.3_all_Arabidopsis_annotated.tsv")
annotation <- merge(annotation1,annotation2, by = "ITAG")

#Only Gene Name and ITAG
annotation <- annotation[,c(1,3,5)]

#fix to one regex
annotation$ITAG <- gsub("^(.*)[.].*", "\\1", annotation$ITAG)
annotation$ITAG <- gsub("^(.*)[.].*", "\\1", annotation$ITAG)

###genesInClust()
#This looks at how many unique genes are in each cluster. 

genesInClust <- function(clustNum, plot.data, annotation) {
  sub_cluster <- subset(plot.data, som$unit.classif==4)
  sub_data <- as.data.frame(sub_cluster[,1])
  colnames(sub_data) <- "ITAG"
  sub_data$ITAG <- gsub("^(.*)[.].*", "\\1", sub_data$ITAG)
  sub_data$ITAG <- gsub("^(.*)[.].*", "\\1", sub_data$ITAG)
  head(sub_data)
  head(annotation)
  resultsTable <- merge(sub_data,annotation,by = "ITAG", all.x=TRUE)
  head(resultsTable)
  print(nrow(unique(resultsTable)))
  return(unique(resultsTable))
  }
```

##1. Get the co-efficient of variation. 

```{r}
countData <- read.csv("../data/normalized_count_file.csv")
dim(countData)
#Then sort
#it adds numbers to them to make them unique but ignore
countData1 <- countData[,order(names(countData))]
countData1 <- subset(countData1, select=c(47,1:46))
```

```{r}
#remove low count libraries (3rd.leaf.7, 2nd.SAM.4, 5th.leaf.3)
dim(countData1)
names(countData1)
countData2 <- countData1[,-c(39,32,11)]
names(countData2)
dim(countData2)
countData2$a1.leaf <- rowMeans(subset(countData2[10:11]))
countData2$a1.SAM <- rowMeans(subset(countData2[12:15]))
countData2$b2.leaf <- rowMeans(subset(countData2[24:27]))
countData2$b2.SAM <- rowMeans(subset(countData2[28:30]))
countData2$c3.leaf <- rowMeans(subset(countData2[31:36]))
countData2$c3.SAM <- rowMeans(subset(countData2[37:44]))
countData2$d4.leaf <- rowMeans(subset(countData2[16:19]))
countData2$d4.SAM <- rowMeans(subset(countData2[20:23]))
countData2$e5.leaf <- rowMeans(subset(countData2[2:5]))
countData2$e5.SAM <- rowMeans(subset(countData2[6:10]))

dim(countData2)
names(countData2)
ave <- subset(countData2[45:54])
ave$sd <- apply(ave,1,function(d)sd(d))
ave$average <- rowMeans(subset(ave[1:10]))
ave$cv <- ave$sd / ave$average
dim(ave)
names(ave)

countData <- cbind(countData, countData2[45:54])
countData <- cbind(countData, ave[,11:13])

names(countData)
```

```{r}
quantile(countData$cv)
countData[is.na(countData)] <- 0
subCountData <- subset(countData, cv > 0.61264422)
allGenes25 <- subCountData[,c(1,48:60)]
colnames(allGenes25)[1]<-"gene"
```

##2.pca

```{r}
#write.csv(allGenes25, "../data/analysis4.top25.csv")
scale_data <- as.matrix(t(scale(t(allGenes25[c(2:11)])))) 

#Principle Component Analysis
pca <- prcomp(scale_data, scale=TRUE) 

summary(pca) 
pca.scores <- data.frame(pca$x)

data.val.allGenes25 <- cbind(allGenes25, scale_data, pca.scores) 
head(data.val.allGenes25)
```

##Visualizing the PCA

```{r}
p <- ggplot(data.val.allGenes25, aes(PC1, PC2))
p + geom_point()
```

#Self Organizing Map - (3,2) Large

```{r}
data.val <- data.val.allGenes25

som.data <- as.matrix(data.val[,c(15:24)])  #subset only the scaled gene expression values

set.seed(2)

som <- som(data=som.data, somgrid(3,2,"hexagonal")) # This is where you change the size of the map
summary(som)
```

-----------------

###Training Plot ("changes") 

```{r}
plot(som, type ="changes")
```

###Code Plot - Large

```{r}
plot(som, type = "codes")
```

###Count Plot - Large

This tells you how many genes are in each of the clusters. The count plot can be used as a quality check.  Ideally you want a uniform distribution.  If there are some peaks in certain areas, this means you should likely increase the map size.  If you have empty nodes you should decrease the map size [1]. 

```{r}
plot(som, type = "counts")
```

###Distance Neighbour Plot - Large

```{r}
plot(som, type="dist.neighbours")
```

###Heatmaps - large

```{r}
head(som$codes)
som$data <- data.frame(som$data) #changed to dataframe to extract column names easier. 

#This is just a loop that plots the distribution of each tissue type across the map. 
for (i in 1:10){
  plot(som, type = "property", property = som$codes[,i], main=names(som$data)[i])
  print(plot)
  }
```

##Visualize by Cluster

```{r}
##Bring the datasets back together for cluster specific visualizations

plot.data <- cbind(data.val[,c(1,15:34)],som$unit.classif,som$distances)
names(plot.data)
head(plot.data)
```

```{r}
p <- ggplot(data.val, aes(PC1, PC2, colour=factor(som$unit.classif))) 
p + geom_point() + theme_bw()
```

##Visualize by cluster

```{r}
clusterVis_line(1)
clusterVis_line(2)
clusterVis_line(3)
clusterVis_line(4)
clusterVis_line(5)
clusterVis_line(6)
clusterVis_line(7)
clusterVis_line(8)
clusterVis_line(9)
```
